// Code generated by counterfeiter. DO NOT EDIT.
package urlfakes

import (
	"sync"

	"github.com/dpb587/metalink"
	"github.com/dpb587/metalink/file"
	"github.com/dpb587/metalink/file/url"
)

type FakeLoader struct {
	LoadURLStub        func(metalink.URL) (file.Reference, error)
	loadURLMutex       sync.RWMutex
	loadURLArgsForCall []struct {
		arg1 metalink.URL
	}
	loadURLReturns struct {
		result1 file.Reference
		result2 error
	}
	loadURLReturnsOnCall map[int]struct {
		result1 file.Reference
		result2 error
	}
	SupportsURLStub        func(metalink.URL) bool
	supportsURLMutex       sync.RWMutex
	supportsURLArgsForCall []struct {
		arg1 metalink.URL
	}
	supportsURLReturns struct {
		result1 bool
	}
	supportsURLReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLoader) LoadURL(arg1 metalink.URL) (file.Reference, error) {
	fake.loadURLMutex.Lock()
	ret, specificReturn := fake.loadURLReturnsOnCall[len(fake.loadURLArgsForCall)]
	fake.loadURLArgsForCall = append(fake.loadURLArgsForCall, struct {
		arg1 metalink.URL
	}{arg1})
	stub := fake.LoadURLStub
	fakeReturns := fake.loadURLReturns
	fake.recordInvocation("LoadURL", []interface{}{arg1})
	fake.loadURLMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLoader) LoadURLCallCount() int {
	fake.loadURLMutex.RLock()
	defer fake.loadURLMutex.RUnlock()
	return len(fake.loadURLArgsForCall)
}

func (fake *FakeLoader) LoadURLCalls(stub func(metalink.URL) (file.Reference, error)) {
	fake.loadURLMutex.Lock()
	defer fake.loadURLMutex.Unlock()
	fake.LoadURLStub = stub
}

func (fake *FakeLoader) LoadURLArgsForCall(i int) metalink.URL {
	fake.loadURLMutex.RLock()
	defer fake.loadURLMutex.RUnlock()
	argsForCall := fake.loadURLArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLoader) LoadURLReturns(result1 file.Reference, result2 error) {
	fake.loadURLMutex.Lock()
	defer fake.loadURLMutex.Unlock()
	fake.LoadURLStub = nil
	fake.loadURLReturns = struct {
		result1 file.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeLoader) LoadURLReturnsOnCall(i int, result1 file.Reference, result2 error) {
	fake.loadURLMutex.Lock()
	defer fake.loadURLMutex.Unlock()
	fake.LoadURLStub = nil
	if fake.loadURLReturnsOnCall == nil {
		fake.loadURLReturnsOnCall = make(map[int]struct {
			result1 file.Reference
			result2 error
		})
	}
	fake.loadURLReturnsOnCall[i] = struct {
		result1 file.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeLoader) SupportsURL(arg1 metalink.URL) bool {
	fake.supportsURLMutex.Lock()
	ret, specificReturn := fake.supportsURLReturnsOnCall[len(fake.supportsURLArgsForCall)]
	fake.supportsURLArgsForCall = append(fake.supportsURLArgsForCall, struct {
		arg1 metalink.URL
	}{arg1})
	stub := fake.SupportsURLStub
	fakeReturns := fake.supportsURLReturns
	fake.recordInvocation("SupportsURL", []interface{}{arg1})
	fake.supportsURLMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLoader) SupportsURLCallCount() int {
	fake.supportsURLMutex.RLock()
	defer fake.supportsURLMutex.RUnlock()
	return len(fake.supportsURLArgsForCall)
}

func (fake *FakeLoader) SupportsURLCalls(stub func(metalink.URL) bool) {
	fake.supportsURLMutex.Lock()
	defer fake.supportsURLMutex.Unlock()
	fake.SupportsURLStub = stub
}

func (fake *FakeLoader) SupportsURLArgsForCall(i int) metalink.URL {
	fake.supportsURLMutex.RLock()
	defer fake.supportsURLMutex.RUnlock()
	argsForCall := fake.supportsURLArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLoader) SupportsURLReturns(result1 bool) {
	fake.supportsURLMutex.Lock()
	defer fake.supportsURLMutex.Unlock()
	fake.SupportsURLStub = nil
	fake.supportsURLReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLoader) SupportsURLReturnsOnCall(i int, result1 bool) {
	fake.supportsURLMutex.Lock()
	defer fake.supportsURLMutex.Unlock()
	fake.SupportsURLStub = nil
	if fake.supportsURLReturnsOnCall == nil {
		fake.supportsURLReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.supportsURLReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLoader) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.loadURLMutex.RLock()
	defer fake.loadURLMutex.RUnlock()
	fake.supportsURLMutex.RLock()
	defer fake.supportsURLMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLoader) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ url.Loader = new(FakeLoader)
